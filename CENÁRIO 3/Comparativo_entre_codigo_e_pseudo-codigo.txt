Comparativo: Implementação de Dijkstra com Fila de Prioridade vs. Pseudocódigo
A nossa implementação em Python do algoritmo de busca de caminho reflete as três etapas principais do pseudocódigo de Dijkstra, mas otimiza a sua execução ao adaptar a estrutura de dados para o ambiente Python, resultando em uma solução mais eficiente.

Inicialização: O pseudocódigo inicializa as distâncias com zero para a origem e infinito para os outros vértices, e define um conjunto para os nós "abertos" (a visitar). Nossa implementação faz o mesmo para as distâncias usando um dicionário, mas substitui o conceito de um simples conjunto de "abertos" por uma fila de prioridade (heapq), uma otimização que garante que o vértice de menor custo seja sempre processado primeiro.

Loop Principal: O pseudocódigo repete o processo até que todos os vértices sejam visitados, descrevendo a etapa chave como "encontrar o vértice com a distância mínima" dentre os abertos. Nossa implementação usa um while loop e a função heappop da fila de prioridade para extrair automaticamente o vértice de menor custo, trocando uma busca potencialmente lenta (O(N)) por uma operação muito mais rápida (O(log N)).

Relaxamento: O pseudocódigo compara o custo do novo caminho (passando por um vértice recém-visitado) com o custo atual de um de seus vizinhos ("sucessores"). Se o novo caminho for mais curto, a distância do vizinho é atualizada. O nosso código implementa essa mesma lógica de "relaxamento" em um loop que percorre os vizinhos do vértice atual (definidos na lista movimentos), atualizando as distâncias no dicionário e adicionando o vizinho à fila de prioridade quando um caminho mais curto é encontrado.
